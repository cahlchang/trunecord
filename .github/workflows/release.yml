name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    if: github.ref_type == 'tag' && startsWith(github.ref_name, 'v')
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false

  build-browser-app:
    name: Build Browser Application
    needs: release
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          # macOS builds (native compilation required)
          - os: macos-latest
            platform: darwin
            arch: amd64
            name: trunecord-darwin-amd64
            dmg_name: trunecord-amd64.dmg
          - os: macos-latest
            platform: darwin
            arch: arm64
            name: trunecord-darwin-arm64
            dmg_name: trunecord-arm64.dmg
          # Windows builds  
          - os: windows-latest
            platform: windows
            arch: amd64
            name: trunecord-windows-amd64
          # Linux builds
          - os: ubuntu-latest
            platform: linux
            arch: amd64
            name: trunecord-linux-amd64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      # Wails is no longer needed for browser app

      # Platform-specific dependencies
      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libayatana-appindicator3-dev
          sudo apt-get install -y build-essential libopus-dev

      - name: Install macOS dependencies  
        if: runner.os == 'macOS'
        run: |
          brew install opus

      - name: Install Windows dependencies
        if: runner.os == 'Windows'
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-opus
            mingw-w64-x86_64-pkg-config
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-binutils
      
      - name: Add MSYS2 to PATH (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          echo "C:\msys64\mingw64\bin" >> $env:GITHUB_PATH

      # Prepare icons for macOS
      - name: Create macOS Icon
        if: runner.os == 'macOS'
        run: |
          cd go-client
          # Create icon from extension assets
          mkdir -p assets
          
          # Find the largest icon file available
          ICON_SOURCE=""
          for size in 512 256 128 64 48 32 16; do
            if [ -f "../extension/assets/icons/icon${size}.png" ]; then
              ICON_SOURCE="../extension/assets/icons/icon${size}.png"
              echo "Using icon source: $ICON_SOURCE"
              break
            fi
          done
          
          if [ -n "$ICON_SOURCE" ]; then
            # Create iconset directory
            ICONSET="assets/AppIcon.iconset"
            rm -rf "$ICONSET"
            mkdir -p "$ICONSET"
            
            # Generate different sizes
            sips -z 16 16     "$ICON_SOURCE" --out "$ICONSET/icon_16x16.png"      > /dev/null 2>&1
            sips -z 32 32     "$ICON_SOURCE" --out "$ICONSET/icon_16x16@2x.png"   > /dev/null 2>&1
            sips -z 32 32     "$ICON_SOURCE" --out "$ICONSET/icon_32x32.png"      > /dev/null 2>&1
            sips -z 64 64     "$ICON_SOURCE" --out "$ICONSET/icon_32x32@2x.png"   > /dev/null 2>&1
            sips -z 128 128   "$ICON_SOURCE" --out "$ICONSET/icon_128x128.png"    > /dev/null 2>&1
            sips -z 256 256   "$ICON_SOURCE" --out "$ICONSET/icon_128x128@2x.png" > /dev/null 2>&1
            sips -z 256 256   "$ICON_SOURCE" --out "$ICONSET/icon_256x256.png"    > /dev/null 2>&1
            sips -z 512 512   "$ICON_SOURCE" --out "$ICONSET/icon_256x256@2x.png" > /dev/null 2>&1
            sips -z 512 512   "$ICON_SOURCE" --out "$ICONSET/icon_512x512.png"    > /dev/null 2>&1
            sips -z 1024 1024 "$ICON_SOURCE" --out "$ICONSET/icon_512x512@2x.png" > /dev/null 2>&1
            
            # Convert to icns
            iconutil -c icns "$ICONSET" -o "assets/AppIcon.icns"
            rm -rf "$ICONSET"
            echo "✅ Created AppIcon.icns"
          else
            echo "⚠️ No icon file found in extension/assets/icons/"
          fi

      # Prepare resources for Windows
      - name: Prepare Windows Resources
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          cd go-client
          
          # Download resource hacker if needed
          if (!(Test-Path "rh.exe")) {
            Invoke-WebRequest -Uri "http://www.angusj.com/resourcehacker/reshacker_setup.exe" -OutFile "reshacker_setup.exe"
            Start-Process -FilePath "reshacker_setup.exe" -ArgumentList "/SILENT" -Wait
            $rhPath = "${env:ProgramFiles(x86)}\Resource Hacker\ResourceHacker.exe"
            if (Test-Path $rhPath) {
              Copy-Item $rhPath "rh.exe"
            }
          }
          
          # Find the largest icon file available
          $iconSource = ""
          foreach ($size in @(512, 256, 128, 64, 48, 32, 16)) {
            $iconPath = "../extension/assets/icons/icon$size.png"
            if (Test-Path $iconPath) {
              $iconSource = (Resolve-Path $iconPath).Path
              Write-Host "Using icon source: $iconSource"
              break
            }
          }
          
          if ($iconSource -ne "") {
            # Use ImageMagick on Windows if available (GitHub Actions has it)
            magick convert "$iconSource" -resize 16x16 icon_16.png
            magick convert "$iconSource" -resize 32x32 icon_32.png
            magick convert "$iconSource" -resize 48x48 icon_48.png
            magick convert "$iconSource" -resize 64x64 icon_64.png
            magick convert "$iconSource" -resize 128x128 icon_128.png
            magick convert "$iconSource" -resize 256x256 icon_256.png
            magick convert icon_16.png icon_32.png icon_48.png icon_64.png icon_128.png icon_256.png trunecord.ico
            Remove-Item icon_*.png
            Write-Host "✅ Created trunecord.ico"
          } else {
            Write-Host "⚠️ No icon file found in extension/assets/icons/"
          }

      # Build the browser application
      - name: Build Browser App
        shell: bash
        env:
          CGO_ENABLED: 1
          GOOS: ${{ matrix.platform }}
          GOARCH: ${{ matrix.arch }}
        run: |
          cd go-client
          mkdir -p build/bin
          if [ "${{ matrix.platform }}" = "windows" ]; then
            # Build with icon embedded for Windows
            if [ -f "trunecord.ico" ]; then
              # Create resource file
              echo '1 ICON "trunecord.ico"' > trunecord.rc
              # Compile resource (if windres is available)
              if command -v windres >/dev/null 2>&1; then
                windres -o trunecord.syso trunecord.rc
              fi
            fi
            go build -o build/bin/trunecord.exe cmd/main.go
            
            # If resource embedding didn't work, try to add icon post-build
            if [ -f "rh.exe" ] && [ -f "trunecord.ico" ]; then
              ./rh.exe -open build/bin/trunecord.exe -save build/bin/trunecord.exe -action addoverwrite -res trunecord.ico -mask ICONGROUP,MAINICON, || true
            fi
          else
            go build -o build/bin/trunecord cmd/main.go
          fi

      # Package for macOS (create DMG with app bundle)
      - name: Create macOS DMG
        if: runner.os == 'macOS'
        run: |
          cd go-client
          mkdir -p dist
          
          # Create app bundle
          APP_NAME="trunecord"
          APP_BUNDLE="build/$APP_NAME.app"
          rm -rf "$APP_BUNDLE"
          mkdir -p "$APP_BUNDLE/Contents/MacOS"
          mkdir -p "$APP_BUNDLE/Contents/Resources"
          
          # Copy binary
          cp build/bin/trunecord "$APP_BUNDLE/Contents/MacOS/"
          chmod +x "$APP_BUNDLE/Contents/MacOS/trunecord"
          
          # Copy icon if exists
          if [ -f "assets/AppIcon.icns" ]; then
            cp "assets/AppIcon.icns" "$APP_BUNDLE/Contents/Resources/AppIcon.icns"
          fi
          
          # Ad-hoc sign the app to prevent "damaged" error
          # This creates a minimal signature that satisfies Gatekeeper
          codesign --force --deep --sign - "$APP_BUNDLE"
          echo "✅ Applied ad-hoc signature to app bundle"
          
          # Create Info.plist
          cat > "$APP_BUNDLE/Contents/Info.plist" << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleExecutable</key>
              <string>trunecord</string>
              <key>CFBundleIdentifier</key>
              <string>com.trunecord.app</string>
              <key>CFBundleName</key>
              <string>trunecord</string>
              <key>CFBundleDisplayName</key>
              <string>trunecord</string>
              <key>CFBundleVersion</key>
              <string>${{ github.ref_name }}</string>
              <key>CFBundleShortVersionString</key>
              <string>${{ github.ref_name }}</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleSignature</key>
              <string>????</string>
              <key>CFBundleInfoDictionaryVersion</key>
              <string>6.0</string>
              <key>CFBundleIconFile</key>
              <string>AppIcon</string>
              <key>LSMinimumSystemVersion</key>
              <string>10.14</string>
              <key>NSHighResolutionCapable</key>
              <true/>
              <key>NSSupportsAutomaticGraphicsSwitching</key>
              <true/>
          </dict>
          </plist>
          EOF
          
          # Create DMG with app bundle
          DMG_TEMP="dist/dmg-temp"
          rm -rf "$DMG_TEMP"
          mkdir -p "$DMG_TEMP"
          
          # Copy app bundle to temp directory
          cp -R "$APP_BUNDLE" "$DMG_TEMP/"
          
          # Create Applications symlink
          ln -s /Applications "$DMG_TEMP/Applications"
          
          # Create README
          cat > "$DMG_TEMP/README.txt" << 'EOF'
          trunecord Installation
          ======================
          
          1. Drag trunecord.app to the Applications folder
          2. Launch trunecord from Applications
          3. The app will open in your browser
          
          Support: https://github.com/cahlchang/trunecord
          EOF
          
          # Create DMG
          hdiutil create -volname "trunecord" \
            -srcfolder "$DMG_TEMP" \
            -ov \
            -format UDZO \
            "dist/${{ matrix.dmg_name }}"
          
          # Clean up temp directory
          rm -rf "$DMG_TEMP"
          
          # Remove quarantine attributes from DMG
          xattr -cr "dist/${{ matrix.dmg_name }}" || true
          echo "✅ Removed quarantine attributes from DMG"

      # Package for Windows (create ZIP)
      - name: Package Windows App
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          cd go-client
          New-Item -ItemType Directory -Force -Path dist
          Compress-Archive -Path "build\bin\trunecord.exe" -DestinationPath "dist\trunecord-windows-amd64.zip"

      # Package for Linux (tar.gz)
      - name: Package Linux App
        if: runner.os == 'Linux'
        run: |
          cd go-client
          mkdir -p dist
          tar -czf dist/trunecord-linux-amd64.tar.gz -C build/bin trunecord

      # Upload Release Assets
      - name: Upload macOS DMG
        if: runner.os == 'macOS'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.release.outputs.upload_url }}
          asset_path: ./go-client/dist/${{ matrix.dmg_name }}
          asset_name: ${{ matrix.dmg_name }}
          asset_content_type: application/x-apple-diskimage

      - name: Upload Windows ZIP
        if: runner.os == 'Windows'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.release.outputs.upload_url }}
          asset_path: ./go-client/dist/trunecord-windows-amd64.zip
          asset_name: trunecord-windows-amd64.zip
          asset_content_type: application/zip

      - name: Upload Linux Archive
        if: runner.os == 'Linux'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.release.outputs.upload_url }}
          asset_path: ./go-client/dist/trunecord-linux-amd64.tar.gz
          asset_name: trunecord-linux-amd64.tar.gz
          asset_content_type: application/gzip

  build-extension:
    name: Build Chrome Extension
    needs: release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Package Chrome Extension
        run: |
          cd extension
          chmod +x scripts/package.sh
          ./scripts/package.sh

      - name: Upload Chrome Extension
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.release.outputs.upload_url }}
          asset_path: ./dist/trunecord-extension.zip
          asset_name: trunecord-chrome-extension.zip
          asset_content_type: application/zip